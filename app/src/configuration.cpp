
#include "configuration.h"


template<>
const eslocal& Configuration::value<eslocal>(InputParameter parameter) const
{
	if (_parameters[parameter]->type() == INTEGER_PARAMETER) {
		return static_cast<IntegerParameter*>(_parameters[parameter])->get();
	} else {
		std::cerr << "Invalid parameter type. ";
		std::cerr << _parameters[parameter]->name() << " is integer value.";
		exit(EXIT_FAILURE);
	}
}

template<>
const std::string& Configuration::value<std::string>(InputParameter parameter) const
{
	if (_parameters[parameter]->type() == STRING_PARAMETER) {
		return static_cast<StringParameter*>(_parameters[parameter])->get();
	} else {
		std::cerr << "Invalid parameter type. ";
		std::cerr << _parameters[parameter]->name() << " is string value.";
		exit(EXIT_FAILURE);
	}
}

template<>
const bool& Configuration::value<bool>(InputParameter parameter) const
{
	if (_parameters[parameter]->type() == BOOLEAN_PARAMETER) {
		return static_cast<BooleanParameter*>(_parameters[parameter])->get();
	} else {
		std::cerr << "Invalid parameter type. ";
		std::cerr << _parameters[parameter]->name() << " is boolean value.";
		exit(EXIT_FAILURE);
	}
}


void Configuration::fillDefaultValues()
{
	_parameters[CMD_LINE_ARGUMENTS] = new StringParameter("CMD_LINE_ARGUMENTS", "Specifies parameters set from command line arguments.", "");

	_parameters[ANSYS_DIR] = new StringParameter("ANSYS_DIR", "A root directory for ANSYS input files.", "");

	_parameters[ANSYS_DIRICHLET_X] = new StringParameter("ANSYS_DIRICHLET_X", "A file with dirichlet condition in x-axis.", "");
	_parameters[ANSYS_DIRICHLET_Y] = new StringParameter("ANSYS_DIRICHLET_Y", "A file with dirichlet condition in y-axis.", "");
	_parameters[ANSYS_DIRICHLET_Z] = new StringParameter("ANSYS_DIRICHLET_Z", "A file with dirichlet condition in z-axis.", "");

	_parameters[ANSYS_FORCES_X] = new StringParameter("ANSYS_FORCES_X", "A file with forces in x-axis.", "");
	_parameters[ANSYS_FORCES_Y] = new StringParameter("ANSYS_FORCES_Y", "A file with forces in y-axis.", "");
	_parameters[ANSYS_FORCES_Z] = new StringParameter("ANSYS_FORCES_Z", "A file with forces in z-axis.", "");

	_parameters[PMCUBE_ELEMENT_TYPE] = new IntegerParameter("PMCUBE_ELEMENT_TYPE", "The type of elements generated by PermonCube.", 0);

	_parameters[PMCUBE_CLUSTERS_X] = new IntegerParameter("PMCUBE_CLUSTERS_X", "Number of clusters in x-axis.", 1);
	_parameters[PMCUBE_CLUSTERS_Y] = new IntegerParameter("PMCUBE_CLUSTERS_Y", "Number of clusters in y-axis.", 1);
	_parameters[PMCUBE_CLUSTERS_Z] = new IntegerParameter("PMCUBE_CLUSTERS_Z", "Number of clusters in z-axis.", 1);

	_parameters[PMCUBE_SUBDOMAINS_X] = new IntegerParameter("PMCUBE_SUBDOMAINS_X", "Number of sub-domains in x-axis.", 2);
	_parameters[PMCUBE_SUBDOMAINS_Y] = new IntegerParameter("PMCUBE_SUBDOMAINS_Y", "Number of sub-domains in y-axis.", 2);
	_parameters[PMCUBE_SUBDOMAINS_Z] = new IntegerParameter("PMCUBE_SUBDOMAINS_Z", "Number of sub-domains in z-axis.", 2);

	_parameters[PMCUBE_ELEMENTS_X] = new IntegerParameter("PMCUBE_ELEMENTS_X", "Number of elements in x-axis.", 5);
	_parameters[PMCUBE_ELEMENTS_Y] = new IntegerParameter("PMCUBE_ELEMENTS_Y", "Number of elements in y-axis.", 5);
	_parameters[PMCUBE_ELEMENTS_Z] = new IntegerParameter("PMCUBE_ELEMENTS_Z", "Number of elements in z-axis.", 5);

	_parameters[PMCUBE_FIX_ZERO_PLANES] = new BooleanParameter("PMCUBE_FIX_ZERO_PLANES", "Dirichlet is set to all nodes in zero planes.", false);
	_parameters[PMCUBE_FIX_BOTTOM] = new BooleanParameter("PMCUBE_FIX_BOTTOM", "Dirichlet is set to all nodes in the bottom plane.", true);

	_parameters[SOLVER_ITERATIONS] = new IntegerParameter("SOLVER_ITERATIONS", "Number of solver iterations.", 100);
}

bool checkCmdLine(std::vector<size_t> &cmdLine, size_t value)
{
	for (size_t i = 0; i < cmdLine.size(); i++) {
		if (cmdLine[i] == value) {
			return true;
		}
	}
	return false;
}

void Configuration::configure(int argc, char** argv)
{
	std::vector<size_t> cmdLine;
	std::vector<bool> configured(_parameters.size(), true);

	// Parse command line arguments
	if (_parameters[CMD_LINE_ARGUMENTS]->isSet()) {
		std::string val = value<std::string>(CMD_LINE_ARGUMENTS);
		while(true) {
			size_t pos = val.find(" ");
			std::string argument = val.substr(0, pos);
			for (size_t i = 0; i < ATTRIBUTES_COUNT; i++) {
				if (_parameters[i]->match(argument)) {
					if (i == 0) {
						std::cerr << "CMD_LINE_ARGUMENTS is not valid parameter in CMD_LINE_ARGUMENTS\n";
						exit(EXIT_FAILURE);
					}
					cmdLine.push_back(i);
					break;
				}
				if (i == ATTRIBUTES_COUNT - 1) {
					std::cerr << "Unknown command line parameter: " << argument << ".\n";
					exit(EXIT_FAILURE);
				}
			}
			val = val.erase(0, pos);
			val = val.erase(0, val.find_first_not_of(" "));
			if (!val.size()) {
				break;
			}
		}
	}
	if (argc - 1 < cmdLine.size()) {
		std::cerr << "Too few command line arguments. ESPRESO assumes " << value<std::string>(CMD_LINE_ARGUMENTS) << "\n";
		exit(EXIT_FAILURE);
	}
	if (argc - 1 > cmdLine.size()) {
		std::cout << "Warning: ESPRESO omits some command line arguments.\n";
	}
	for (size_t i = 0; i < cmdLine.size(); i++) {
		_parameters[cmdLine[i]]->set(std::string(_parameters[cmdLine[i]]->name() + "=" + argv[i + 1]));
	}


	// Parse ANSYS arguments
	for (size_t i = ANSYS_DIR; i <= ANSYS_FORCES_Z; i++) {
		if (_parameters[i]->isSet()) {
			if (checkCmdLine(cmdLine, i)) {
				std::cout << "Warning: parameter " << _parameters[i]->name() << " is ignored. It is command line argument.\n";
			} else if (i != ANSYS_DIR && (!_parameters[ANSYS_DIR]->isSet() || checkCmdLine(cmdLine, ANSYS_DIR))) {
				std::cout << "Warning: parameter " << _parameters[i]->name() << " is ignored. Set parameter ANSYS_DIR first.\n";
			}
		} else {
			configured[i] = false;
		}
	}

	// Parse PermonCube arguments
	for (size_t i = PMCUBE_ELEMENT_TYPE; i <= PMCUBE_ELEMENTS_Z; i++) {
		if (_parameters[ANSYS_DIR]->isSet()) {
			std::cout << "Warning: parameter " << _parameters[i]->name() << " is ignored. ANSYS has higher priority.\n";
			configured[i] = false;
		} else if (checkCmdLine(cmdLine, i)) {
			std::cout << "Warning: parameter " << _parameters[i]->name() << " is ignored. It is command line argument.\n";
		}
	}
	if (_parameters[PMCUBE_FIX_ZERO_PLANES]->isSet() && _parameters[PMCUBE_FIX_BOTTOM]->isSet()) {
		std::cout << "Warning: parameter PMCUBE_FIX_BOTTOM is ignored. PMCUBE_FIX_ZERO_PLANES has higher priority.\n";
		configured[PMCUBE_FIX_BOTTOM] = false;
	} else {
		if (_parameters[PMCUBE_FIX_ZERO_PLANES]->isSet()) {
			configured[PMCUBE_FIX_BOTTOM] = false;
		}
		if (_parameters[PMCUBE_FIX_BOTTOM]->isSet()) {
			configured[PMCUBE_FIX_ZERO_PLANES] = false;
		}
	}

	for (size_t i = 0; i < _parameters.size(); i++) {
		_parameters[i]->reset(configured[i]);
	}
}

Configuration::Configuration(std::string configFile, int argc, char** argv)
	: _parameters(ATTRIBUTES_COUNT)
{
	fillDefaultValues();

	std::ifstream file(configFile);

	if (file.is_open()) {
		std::string line;

		while (getline(file, line, '\n')) {
			if (!line.size() || line.compare(0, 1, "#") == 0) {
				continue;
			}
			size_t pos = line.find("#");
			if (pos < std::string::npos) {
				line = line.substr(0, pos);
			}
			for (size_t i = 0; i < _parameters.size(); i++) {
				if (_parameters[i]->match(line)) {
					if (_parameters[i]->isSet()) {
						std::cout << "Warning: parameter " << _parameters[i]->name() << " is set more than once.";
					}
					_parameters[i]->set(line);
					break;
				}
				if (i == _parameters.size() - 1) {
					std::cerr << "Unknown parameter in configuration file: " << line << ".\n";
					exit(EXIT_FAILURE);
				}
			}
		}

		file.close();
	} else {
		std::cout << "File '" << configFile << "' not found.\n";
	}

	configure(argc, argv);
}

void Configuration::print() const
{
	for (size_t i = 0; i < _parameters.size(); i++) {
		if (!_parameters[i]->isSet()) {
			continue;
		}
		std::cout << _parameters[i]->name() << " = ";
		switch (_parameters[i]->type()) {
			case STRING_PARAMETER: {
				std::cout << "'" << value<std::string>(i) << "'";
				break;
			}
			case INTEGER_PARAMETER: {
				std::cout << value<eslocal>(i);
				break;
			}
			case BOOLEAN_PARAMETER: {
				if (value<bool>(i)) {
					std::cout << "true";
				} else {
					std::cout << "false";
				}
				break;
			}
		}
		std::cout << "\n";
	}
}

void Configuration::description() const
{
	for (size_t i = 0; i < _parameters.size(); i++) {
		std::cout << _parameters[i]->name() << ": " << _parameters[i]->description() << "\n";
	}
}

Configuration::~Configuration()
{
	for (size_t i = 0; i < _parameters.size(); i++) {
		delete _parameters[i];
	}
}


