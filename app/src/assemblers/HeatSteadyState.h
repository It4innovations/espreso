#ifndef APP_SRC_ASSEMBLERS_HEATSTEADYSTATE_H_
#define APP_SRC_ASSEMBLERS_HEATSTEADYSTATE_H_

#include "assembler.h"
#include "esmesh.h"
#include "essolver.h"

class HeatSteadyState: public Assembler {

public:
	HeatSteadyState(const Instance &instance): Assembler(instance) { };

	void init();
	void pre_solve_update();
	void post_solve_update();
	void solve();
	void finalize();

private:

    eslocal MPI_rank;
    eslocal MPI_size;

	// Matrices for Mesh generator and Assembler
	std::vector < SparseCSRMatrix<eslocal> > K_mat;
	std::vector < SparseIJVMatrix<eslocal> > B1_mat;
	std::vector < SparseIJVMatrix<eslocal> > B0_mat;

	// Matrices for Linear Solver
	std::vector < SparseMatrix >	K_mat_ls;
	std::vector < SparseMatrix >	B1_mat_ls;
	std::vector < SparseMatrix >	B0_mat_ls;

	// Suporting data required for communication layer - all generated by generator of Matrix B
	std::vector < std::vector <eslocal> >	 lambda_map_sub_B1;
	std::vector < std::vector <eslocal> >	 lambda_map_sub_B0;
	std::vector < std::vector <eslocal> >	 lambda_map_sub_clst;
	std::vector < std::vector <double> >	 B1_duplicity;		//VAHOVA FUNKCE
	std::vector < std::vector <double> >	 vec_c;
	std::vector < std::vector <eslocal> >	 l2g_vec; 			// l2g vector per cluster - not for entire problem


	std::vector < std::vector <double > >	 f_vec;				// Right hand side
	vector < vector < double > > 			 prim_solution; 	// solution will be saved into this vector


	std::vector < std::vector <eslocal > >	 fix_nodes;

	std::vector < eslocal > 				 neigh_clusters;	// list of neighboring cluster - defined by their MPI rank


	size_t partsCount; 											//number of domains per cluster
	int DOFS_PER_NODE;											// number of degrees of freedom per one node

	//Time measurement instances
	TimeEval timeEvalMain;										// Time measurement instancefor overal solver runtime

	// ESPRESO Linear Solver instance
	LinearSolver lin_solver; // espreso solver class to be determined



};

#endif /* APP_SRC_ASSEMBLERS_HEATSTEADYSTATE_H_ */
